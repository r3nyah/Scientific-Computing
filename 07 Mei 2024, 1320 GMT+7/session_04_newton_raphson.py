# -*- coding: utf-8 -*-
"""Session 04_newton_raphson.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hdbsrH7OIGDbfkA6Upu6Q9xHR-ZyunpP
"""

import numpy as np

def my_bisection (f,a,b,tol):
  # approximates a root, R of F bounded by A and B to within tolerance
  # | f(m) | < tol with m the midpoint between A and B recursive implementation

  # check if A and B bound a root
  if np.sign(f(a)) == np.sign(f(b)):
    raise Exception("The scalars A and B do not bound a root")

  # get mid point
  m = (a + b) / 2

  if np.abs(f(m)) < tol:
    # stoping condition, report M as root
    return m
  elif np.sign(f(a)) == np.sign(f(m)):
    # case where m is an improvement on a
    # make recursive call ith a  = m
    return my_bisection(f,m,b,tol)
  elif np.sign(f(b)) == np.sign(f(m)):
    # case where m is an improvement on b
    # make recursive call ith b  = m
    return my_bisection(f,a,m,tol)

f = lambda x: x**2 - 2

r1 = my_bisection(f,0,2,0.1)
print("r1 = ", r1)

r01 = my_bisection(f,0,2,0.01)
print("r01 = ", r01)

print("f(r1) = ",f(r1))
print("f(r01) = ",(r01))

f = lambda x: x**2 - 2
f_prime = lambda x: 2*x
newton_raphson = 1.4 - (f(1.4)) / (f_prime(1.4))

print("newton_raphson = ", newton_raphson)
print("swrt(2) = ",np.sqrt(2))

def my_newton(f,df,x0,tol):
  # output is an estimation of the root of f using the newton raphson method
  # recursive method implementation

  if abs(f(x0)) < tol:
    return x0
  else:
    return my_newton(f,df,x0 - f(x0) / df(x0),tol)

