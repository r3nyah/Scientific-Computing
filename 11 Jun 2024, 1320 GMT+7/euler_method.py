# -*- coding: utf-8 -*-
"""Euler Method.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XfRHQIpmQY2dfBHOs0ROnusMEbOIxPMt
"""

import numpy as np
import matplotlib.pyplot as plt

# Commented out IPython magic to ensure Python compatibility.
plt.style.use("seaborn-v0_8")
# %matplotlib inline

#Define parameters
f = lambda t, s: np.exp(-t) # ODE
h = 0.1 #Step size
t = np.arange(0,1 + h,h) # Numerical grid
s0 = -1 # Initial Condition

#Explicit Euler Method
s = np.zeros(len(t))
s[0] = s0

for i in range(0,len(t) -  1):
  s[i + 1] = s[i] + h*f(t[i], s[i])

plt.figure(figsize = (12,8))
plt.plot(t, s, 'bo--',label='Approximate')
plt.plot(t, -np.exp(-t), 'g',label='Exact')
plt.title('Approximate and Exact Solution \
for Simple ODE')
plt.xlabel('t')
plt.ylabel('f(t)')
plt.grid()
plt.legend(loc='lower right')
plt.show()

h = 0.01 # Step size
t = np.arange(0, 1+ h,h) # Numerical grid
s0 = -1# Initial Condition
# Explicit Euler Method
s = np.zeros(len(t))
s[0] = s0
for i in range(0, len(t) - 1):
  s[i + 1] = s[i] + h*f(t[i], s[i])
plt.figure(figsize = (12, 8))
plt.plot(t, s, 'b--', label='Approximate')
plt.plot(t, -np.exp(-t), 'g', label='Exact')
plt.title('Approximate and Exact Solution \
for Simple ODE')
plt.xlabel('t')
plt.ylabel('f(t)')
plt.grid()
plt.legend(loc='lower right')
plt.show()

"""**QUIZ 1** \
y` + 4y = x^2 \
y(0) = 1
"""

h = 0.01
t = np.arange(0, 1 + h, h)
y0 = 1

def f(t, y):
    return t**2 - 4*y

y = np.zeros(len(t))
y[0] = y0
for i in range(0, len(t) - 1):
    y[i + 1] = y[i] + h * f(t[i], y[i])

plt.figure(figsize=(10, 6))
plt.plot(t, y, 'b--', label='Approximate')
plt.title('Approximate and Exact Solution for Simple ODE')
plt.xlabel('t')
plt.ylabel('y(t)')
plt.grid()
plt.legend(loc='lower right')
plt.show()

"""**QUIZ 2**
y` = sin y ;
y(0) = 1 ;
from x = 0 to 0.5 in steps of h = 0.1. Keep four decimal places in th computations.
"""

import numpy as np
import matplotlib.pyplot as plt

h = 0.1
t = np.arange(0, 0.5 + h, h)
y0 = 1

def f(t, y):
    return np.sin(y)

y = np.zeros(len(t))
y[0] = y0
for i in range(0, len(t) - 1):
    y[i + 1] = y[i] + h * f(t[i], y[i])
    y[i + 1] = round(y[i + 1], 4)

plt.figure(figsize=(12, 8))
plt.plot(t, y, 'b--', label='Approximate')
plt.title('Approximate Solution for Simple ODE')
plt.xlabel('t')
plt.ylabel('y(t)')
plt.grid()
plt.legend(loc='lower right')
plt.show()